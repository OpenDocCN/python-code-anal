# AutoGPT源码解析 26

# `benchmark/agbenchmark/agent_protocol_client/rest.py`

这段代码定义了一个名为 `AgentCommunicationProtocol` 的类，该类提供了一个 API 协议，用于与代理进行通信。这个 API 协议的具体信息包含在协议的文档中，该文档由 OpenAPI Generator 生成。因此，该代码的作用是定义了一个通信协议，以便在程序中使用。


```py
# coding: utf-8

"""
    Agent Communication Protocol

    Specification of the API protocol for communication with an agent.  # noqa: E501

    The version of the OpenAPI document: v0.2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


import io
```

这段代码的作用是使用Python的一些第三方库，包括`json`、`logging`、`re`、`ssl`、`urllib.parse`和`aiohttp`，实现对HTTP请求的发送和解析。

具体来说，这段代码：

1. 引入了`json`、`logging`、`re`、`ssl`、`urllib.parse`和`aiohttp`库。
2. 定义了一个`RESTResponse`类，用于表示HTTP请求的响应数据。在`__init__`方法中，将原始响应数据赋值给`aiohttp_response`属性，并获取响应状态码和响应原因。
3. 在`getheaders`方法中，返回一个`CIMMultiDictProxy`对象，包含了所有响应头。
4. 在`getheader`方法中，接收一个`name`参数和一个`default`参数，返回响应头中与`name`相同的值，如果没有匹配的名称，则返回`None`。
5. 引入了`agbenchmark.agent_protocol_client.exceptions`和`agbenchmark.agent_protocol_client.base_classes`。
6. 在`RESTResponse`类中，添加了以下两个静态方法：`__enter__`和`__exit__`。
	* `__enter__`方法用于设置响应对象引用计数，使得对象可以无限次使用。
	* `__exit__`方法在对象不再需要时执行，清除对象引用计数。

这段代码的作用是帮助开发者更方便地编写HTTP请求的代码，并提供了响应数据的一些常用方法，以方便用户进行处理和解析。


```py
import json
import logging
import re
import ssl
from urllib.parse import urlencode

import aiohttp

from agbenchmark.agent_protocol_client.exceptions import ApiException, ApiValueError

logger = logging.getLogger(__name__)


class RESTResponse(io.IOBase):
    def __init__(self, resp, data):
        self.aiohttp_response = resp
        self.status = resp.status
        self.reason = resp.reason
        self.data = data

    def getheaders(self):
        """Returns a CIMultiDictProxy of the response headers."""
        return self.aiohttp_response.headers

    def getheader(self, name, default=None):
        """Returns a given response header."""
        return self.aiohttp_response.headers.get(name, default)


```

This is a class called `API` which is used to interact with an API. It has methods to perform different CRUD (Create, Read, Update, Delete) operations. These methods are using the `requests` library to make the HTTP requests to the API endpoint. The `API` class has also been pre-forked under the hood by Bit (`@bit.tech/api`).

The class also has a `post_request` method which is used for making POST (Create) requests and a `put_request` method which is used for making PUT (Update) requests. The `post_request` and `put_request` methods have similar arguments as mentioned in the documentation of the `requests` library.

In the example, the `API` class is initialized with a base URL and some headers. Then, the class is making a DELETE request to that URL using the `request` method. This method is responsible for sending the DELETE request to the API endpoint and handling the response.

The `post_request` and `put_request` methods are then making the respective operations on the API endpoint using the `request` method. These methods handle the sending of the HTTP request and the parsing of the response.

Finally, the `API` class is using the `response` method to get the response from the API.

Overall, the `API` class provides a simple and easy-to-use interface for making CRUD operations with an API.


```py
class RESTClientObject(object):
    def __init__(self, configuration, pools_size=4, maxsize=None):
        # maxsize is number of requests to host that are allowed in parallel
        if maxsize is None:
            maxsize = configuration.connection_pool_maxsize

        ssl_context = ssl.create_default_context(cafile=configuration.ssl_ca_cert)
        if configuration.cert_file:
            ssl_context.load_cert_chain(
                configuration.cert_file, keyfile=configuration.key_file
            )

        if not configuration.verify_ssl:
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl.CERT_NONE

        connector = aiohttp.TCPConnector(limit=maxsize, ssl=ssl_context)

        self.proxy = configuration.proxy
        self.proxy_headers = configuration.proxy_headers

        # https pool manager
        self.pool_manager = aiohttp.ClientSession(connector=connector, trust_env=True)

    async def close(self):
        await self.pool_manager.close()

    async def request(
        self,
        method,
        url,
        query_params=None,
        headers=None,
        body=None,
        post_params=None,
        _preload_content=True,
        _request_timeout=None,
    ):
        """Execute request

        :param method: http request method
        :param url: http request url
        :param query_params: query parameters in the url
        :param headers: http request headers
        :param body: request json body, for `application/json`
        :param post_params: request post parameters,
                            `application/x-www-form-urlencoded`
                            and `multipart/form-data`
        :param _preload_content: this is a non-applicable field for
                                 the AiohttpClient.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        """
        method = method.upper()
        assert method in ["GET", "HEAD", "DELETE", "POST", "PUT", "PATCH", "OPTIONS"]

        if post_params and body:
            raise ApiValueError(
                "body parameter cannot be used with post_params parameter."
            )

        post_params = post_params or {}
        headers = headers or {}
        # url already contains the URL query string
        # so reset query_params to empty dict
        query_params = {}
        timeout = _request_timeout or 5 * 60

        if "Content-Type" not in headers:
            headers["Content-Type"] = "application/json"

        args = {"method": method, "url": url, "timeout": timeout, "headers": headers}

        if self.proxy:
            args["proxy"] = self.proxy
        if self.proxy_headers:
            args["proxy_headers"] = self.proxy_headers

        if query_params:
            args["url"] += "?" + urlencode(query_params)

        # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
        if method in ["POST", "PUT", "PATCH", "OPTIONS", "DELETE"]:
            if re.search("json", headers["Content-Type"], re.IGNORECASE):
                if body is not None:
                    body = json.dumps(body)
                args["data"] = body
            elif (
                headers["Content-Type"] == "application/x-www-form-urlencoded"
            ):  # noqa: E501
                args["data"] = aiohttp.FormData(post_params)
            elif headers["Content-Type"] == "multipart/form-data":
                # must del headers['Content-Type'], or the correct
                # Content-Type which generated by aiohttp
                del headers["Content-Type"]
                data = aiohttp.FormData()
                for param in post_params:
                    k, v = param
                    if isinstance(v, tuple) and len(v) == 3:
                        data.add_field(k, value=v[1], filename=v[0], content_type=v[2])
                    else:
                        data.add_field(k, v)
                args["data"] = data

            # Pass a `bytes` parameter directly in the body to support
            # other content types than Json when `body` argument is provided
            # in serialized form
            elif isinstance(body, bytes):
                args["data"] = body
            else:
                # Cannot generate the request from given parameters
                msg = """Cannot prepare a request message for provided
                         arguments. Please check that your arguments match
                         declared content type."""
                raise ApiException(status=0, reason=msg)

        r = await self.pool_manager.request(**args)
        if _preload_content:
            data = await r.read()
            r = RESTResponse(r, data)

            # log response body
            logger.debug("response body: %s", r.data)

            if not 200 <= r.status <= 299:
                raise ApiException(http_resp=r)

        return r

    async def get_request(
        self,
        url,
        headers=None,
        query_params=None,
        _preload_content=True,
        _request_timeout=None,
    ):
        return await self.request(
            "GET",
            url,
            headers=headers,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
            query_params=query_params,
        )

    async def head_request(
        self,
        url,
        headers=None,
        query_params=None,
        _preload_content=True,
        _request_timeout=None,
    ):
        return await self.request(
            "HEAD",
            url,
            headers=headers,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
            query_params=query_params,
        )

    async def options_request(
        self,
        url,
        headers=None,
        query_params=None,
        post_params=None,
        body=None,
        _preload_content=True,
        _request_timeout=None,
    ):
        return await self.request(
            "OPTIONS",
            url,
            headers=headers,
            query_params=query_params,
            post_params=post_params,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
            body=body,
        )

    async def delete_request(
        self,
        url,
        headers=None,
        query_params=None,
        body=None,
        _preload_content=True,
        _request_timeout=None,
    ):
        return await self.request(
            "DELETE",
            url,
            headers=headers,
            query_params=query_params,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
            body=body,
        )

    async def post_request(
        self,
        url,
        headers=None,
        query_params=None,
        post_params=None,
        body=None,
        _preload_content=True,
        _request_timeout=None,
    ):
        return await self.request(
            "POST",
            url,
            headers=headers,
            query_params=query_params,
            post_params=post_params,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
            body=body,
        )

    async def put_request(
        self,
        url,
        headers=None,
        query_params=None,
        post_params=None,
        body=None,
        _preload_content=True,
        _request_timeout=None,
    ):
        return await self.request(
            "PUT",
            url,
            headers=headers,
            query_params=query_params,
            post_params=post_params,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
            body=body,
        )

    async def patch_request(
        self,
        url,
        headers=None,
        query_params=None,
        post_params=None,
        body=None,
        _preload_content=True,
        _request_timeout=None,
    ):
        return await self.request(
            "PATCH",
            url,
            headers=headers,
            query_params=query_params,
            post_params=post_params,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
            body=body,
        )

```

# `benchmark/agbenchmark/agent_protocol_client/__init__.py`

这段代码定义了一个名为 "Agent Communication Protocol" 的类，用于描述与智能代理进行通信的 API 协议。

该类包含一个元数据字符串 "Agent Communication Protocol v0.2"，指定了该 API 协议的版本为 0.2。同时，它还包含一个元数据字符串 "noqa"，用于告知开发人员该代码存在一些潜在的 QA 问题，以帮助他们编写更好的代码。

该类的其余部分包含了一些方法，用于实现与智能代理进行通信的 API 协议。例如，该类有一个 "get_agent" 方法，用于获取指定智能代理的 ID。


```py
# coding: utf-8

# flake8: noqa

"""
    Agent Communication Protocol

    Specification of the API protocol for communication with an agent.  # noqa: E501

    The version of the OpenAPI document: v0.2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


```

该代码是一个Python脚本，它的作用是定义了一个名为“__version__”的常量，其值为“1.0.0”。

接下来，该脚本通过导入来自“agbenchmark.agent_protocol_client.api.agent_api”的“AgentApi”类，以及来自“agbenchmark.agent_protocol_client.api_client”的“ApiClient”类，使得该脚本可以访问与这两个类相关的API。

然后，该脚本通过导入自“agbenchmark.agent_protocol_client.api_response”的“ApiResponse”类，使得您可以从API返回的数据中获取信息。

接着，该脚本从“agbenchmark.agent_protocol_client.configuration”的“Configuration”类中导入了一个配置文件，配置文件包含了用于与API通信的凭据。

最后，该脚本定义了一些异常类，这些异常类可以捕获由于API访问导致的各种错误，包括“ApiAttributeError”、“ApiException”、“ApiKeyError”、“ApiTypeError”和“ApiValueError”。


```py
__version__ = "1.0.0"

# import apis into sdk package
from agbenchmark.agent_protocol_client.api.agent_api import AgentApi
from agbenchmark.agent_protocol_client.api_client import ApiClient

# import ApiClient
from agbenchmark.agent_protocol_client.api_response import ApiResponse
from agbenchmark.agent_protocol_client.configuration import Configuration
from agbenchmark.agent_protocol_client.exceptions import (
    ApiAttributeError,
    ApiException,
    ApiKeyError,
    ApiTypeError,
    ApiValueError,
    OpenApiException,
)

```

这段代码的作用是导入Agbenchmark中的模型到SDK包中，并定义了Artifact、Step、StepAllOf和Task等模型类。

在Agbenchmark中，每个模型类都定义了API消息的接口，这些接口在SDK中进行了一一对应的关系。通过导入这些模型类到SDK中，可以使得SDK应用更加灵活，能够支持不同的Agbenchmark模型。

具体来说，这段代码中定义了以下类：

- Artifact类：表示Agbenchmark中的艺术品，可以使用该类来定义SDK中的艺术品消息。
- Step类：表示Agbenchmark中的步骤，可以使用该类来定义SDK中的步骤消息。
- StepAllOf类：表示由多个步骤组成的复杂步骤，可以使用该类来定义SDK中的复杂步骤消息。
- StepRequestBody类：表示Agbenchmark中的请求消息，可以使用该类来定义SDK中的请求消息。
- Task类：表示Agbenchmark中的任务，可以使用该类来定义SDK中的任务消息。
- TaskAllOf类：表示由多个任务组成的复杂任务，可以使用该类来定义SDK中的复杂任务消息。
- TaskRequestBody类：表示Agbenchmark中的请求消息，可以使用该类来定义SDK中的请求消息。


```py
# import models into sdk package
from agbenchmark.agent_protocol_client.models.artifact import Artifact
from agbenchmark.agent_protocol_client.models.step import Step
from agbenchmark.agent_protocol_client.models.step_all_of import StepAllOf
from agbenchmark.agent_protocol_client.models.step_request_body import StepRequestBody
from agbenchmark.agent_protocol_client.models.task import Task
from agbenchmark.agent_protocol_client.models.task_all_of import TaskAllOf
from agbenchmark.agent_protocol_client.models.task_request_body import TaskRequestBody

```

# `benchmark/agbenchmark/agent_protocol_client/api/agent_api.py`

这段代码定义了一个名为"Agent Communication Protocol"的类，它描述了与代理进行通信的API协议。这个类中定义了一个名为"Specification of the API protocol for communication with an agent"的常量，它指定了这个API协议的版本为v0.2。

此外，这个类中还定义了一个名为"The version of the OpenAPI document: v0.2"的常量，它指定了API协议的文档版本为v0.2。

最后，这个类中使用了一个名为"specification of the API protocol for communication with an agent"的评论，它指出了这个类中定义的常量的目的是为了描述与代理进行通信的API协议。


```py
# coding: utf-8

"""
    Agent Communication Protocol

    Specification of the API protocol for communication with an agent.  # noqa: E501

    The version of the OpenAPI document: v0.2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


import re  # noqa: F401
```

这段代码定义了一个完整的 Agbenchmark Agent Protocol Client的客户端接口，用于与该接口进行交互。

它从typing库中引入了Any、Awaitable、List、Optional、Union和overload类型。

它从pydantic库中引入了Field、Annotated类型。

它从typing_extensions库中引入了Annotated类型。

它从Agbenchmark Agent Protocol Client的API客户端类中继承了ApiClient类。

它从Agbenchmark Agent Protocol Client的API响应类中继承了ApiResponse类。

它从Agbenchmark Agent Protocol Client的异常类中继承了ApiTypeError和ApiValueError类。

它从Agbenchmark Agent Protocol Client的Artifact类中继承了Artifact类。

它从Agbenchmark Agent Protocol Client的Step类中继承了Step类。

它从Agbenchmark Agent Protocol Client的StepRequestBody类中继承了StepRequestBody类。

它从Agbenchmark Agent Protocol Client的Task类中继承了Task类。

该代码片段定义了一个名为ArtifactClient的类，用于与Agbenchmark Agent Protocol Client的API进行交互。

该类实现了以下接口：

```py
from typing import Any, Awaitable, List, Optional, Union, overload
from pydantic import Field, StrictBytes, StrictStr, validate_arguments
from typing_extensions import Annotated
```


```py
from typing import Any, Awaitable, List, Optional, Union, overload

from pydantic import Field, StrictBytes, StrictStr, validate_arguments
from typing_extensions import Annotated

from agbenchmark.agent_protocol_client.api_client import ApiClient
from agbenchmark.agent_protocol_client.api_response import ApiResponse
from agbenchmark.agent_protocol_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError,
)
from agbenchmark.agent_protocol_client.models.artifact import Artifact
from agbenchmark.agent_protocol_client.models.step import Step
from agbenchmark.agent_protocol_client.models.step_request_body import StepRequestBody
from agbenchmark.agent_protocol_client.models.task import Task
```

This is a code snippet in Python that defines an interface for working with task agents. The task agent can be used to perform various operations, such as uploading artifacts or creating new tasks.

The code defines several parameters that can be passed to the task agent using the `/agent/tasks/{task_id}/artifacts` endpoint. These parameters include the ID of the task, the type of artifact to be uploaded, and an optional relative path to the artifact.

The code also defines several endpoints that can be used to set the HTTP headers of the task agent. These endpoints include the `/agent/config` endpoint, which can be used to update the task agent's configuration, and the `/agent/log` endpoint, which can be used to log messages from the task agent.

The code also defines a dictionary of response types that the task agent can use to indicate the expected response data for each endpoint. For example, the `/agent/config/update` endpoint returns a JSON object containing the updated task agent configuration.

Overall, this code snippet provides a foundation for working with task agents in Python.


```py
from agbenchmark.agent_protocol_client.models.task_request_body import TaskRequestBody


class AgentApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @overload
    async def create_agent_task(
        self, task_request_body: Optional[TaskRequestBody] = None, **kwargs
    ) -> Task:  # noqa: E501
        ...

    @overload
    def create_agent_task(
        self,
        task_request_body: Optional[TaskRequestBody] = None,
        async_req: Optional[bool] = True,
        **kwargs,
    ) -> Task:  # noqa: E501
        ...

    @validate_arguments
    def create_agent_task(
        self,
        task_request_body: Optional[TaskRequestBody] = None,
        async_req: Optional[bool] = None,
        **kwargs,
    ) -> Union[Task, Awaitable[Task]]:  # noqa: E501
        """Creates a task for the agent.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_agent_task(task_request_body, async_req=True)
        >>> result = thread.get()

        :param task_request_body:
        :type task_request_body: TaskRequestBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Task
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the create_agent_task_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.create_agent_task_with_http_info(
            task_request_body, **kwargs
        )  # noqa: E501

    @validate_arguments
    def create_agent_task_with_http_info(
        self, task_request_body: Optional[TaskRequestBody] = None, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """Creates a task for the agent.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_agent_task_with_http_info(task_request_body, async_req=True)
        >>> result = thread.get()

        :param task_request_body:
        :type task_request_body: TaskRequestBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Task, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["task_request_body"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_agent_task" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["task_request_body"] is not None:
            _body_params = _params["task_request_body"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "Task",
        }

        return self.api_client.call_api(
            "/agent/tasks",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def download_agent_task_artifact(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        artifact_id: Annotated[StrictStr, Field(..., description="ID of the artifact")],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        ...

    @overload
    def download_agent_task_artifact(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        artifact_id: Annotated[StrictStr, Field(..., description="ID of the artifact")],
        async_req: Optional[bool] = True,
        **kwargs,
    ) -> bytearray:  # noqa: E501
        ...

    @validate_arguments
    def download_agent_task_artifact(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        artifact_id: Annotated[StrictStr, Field(..., description="ID of the artifact")],
        async_req: Optional[bool] = None,
        **kwargs,
    ) -> Union[bytearray, Awaitable[bytearray]]:  # noqa: E501
        """Download a specified artifact.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.download_agent_task_artifact(task_id, artifact_id, async_req=True)
        >>> result = thread.get()

        :param task_id: ID of the task (required)
        :type task_id: str
        :param artifact_id: ID of the artifact (required)
        :type artifact_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the download_agent_task_artifact_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.download_agent_task_artifact_with_http_info(
            task_id, artifact_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def download_agent_task_artifact_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        artifact_id: Annotated[StrictStr, Field(..., description="ID of the artifact")],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Download a specified artifact.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.download_agent_task_artifact_with_http_info(task_id, artifact_id, async_req=True)
        >>> result = thread.get()

        :param task_id: ID of the task (required)
        :type task_id: str
        :param artifact_id: ID of the artifact (required)
        :type artifact_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["task_id", "artifact_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_agent_task_artifact" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["task_id"]:
            _path_params["task_id"] = _params["task_id"]

        if _params["artifact_id"]:
            _path_params["artifact_id"] = _params["artifact_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return self.api_client.call_api(
            "/agent/tasks/{task_id}/artifacts/{artifact_id}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def execute_agent_task_step(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        step_request_body: Optional[StepRequestBody] = None,
        **kwargs,
    ) -> Step:  # noqa: E501
        ...

    @overload
    def execute_agent_task_step(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        step_request_body: Optional[StepRequestBody] = None,
        async_req: Optional[bool] = True,
        **kwargs,
    ) -> Step:  # noqa: E501
        ...

    @validate_arguments
    def execute_agent_task_step(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        step_request_body: Optional[StepRequestBody] = None,
        async_req: Optional[bool] = None,
        **kwargs,
    ) -> Union[Step, Awaitable[Step]]:  # noqa: E501
        """Execute a step in the specified agent task.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.execute_agent_task_step(task_id, step_request_body, async_req=True)
        >>> result = thread.get()

        :param task_id: ID of the task (required)
        :type task_id: str
        :param step_request_body:
        :type step_request_body: StepRequestBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Step
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the execute_agent_task_step_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.execute_agent_task_step_with_http_info(
            task_id, step_request_body, **kwargs
        )  # noqa: E501

    @validate_arguments
    def execute_agent_task_step_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        step_request_body: Optional[StepRequestBody] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Execute a step in the specified agent task.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.execute_agent_task_step_with_http_info(task_id, step_request_body, async_req=True)
        >>> result = thread.get()

        :param task_id: ID of the task (required)
        :type task_id: str
        :param step_request_body:
        :type step_request_body: StepRequestBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Step, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["task_id", "step_request_body"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method execute_agent_task_step" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["task_id"]:
            _path_params["task_id"] = _params["task_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["step_request_body"] is not None:
            _body_params = _params["step_request_body"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "Step",
        }

        return self.api_client.call_api(
            "/agent/tasks/{task_id}/steps",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def get_agent_task(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        **kwargs,
    ) -> Task:  # noqa: E501
        ...

    @overload
    def get_agent_task(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        async_req: Optional[bool] = True,
        **kwargs,
    ) -> Task:  # noqa: E501
        ...

    @validate_arguments
    def get_agent_task(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        async_req: Optional[bool] = None,
        **kwargs,
    ) -> Union[Task, Awaitable[Task]]:  # noqa: E501
        """Get details about a specified agent task.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_agent_task(task_id, async_req=True)
        >>> result = thread.get()

        :param task_id: ID of the task (required)
        :type task_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Task
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the get_agent_task_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.get_agent_task_with_http_info(task_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_agent_task_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Get details about a specified agent task.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_agent_task_with_http_info(task_id, async_req=True)
        >>> result = thread.get()

        :param task_id: ID of the task (required)
        :type task_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Task, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["task_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_agent_task" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["task_id"]:
            _path_params["task_id"] = _params["task_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "Task",
        }

        return self.api_client.call_api(
            "/agent/tasks/{task_id}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def get_agent_task_step(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        step_id: Annotated[StrictStr, Field(..., description="ID of the step")],
        **kwargs,
    ) -> Step:  # noqa: E501
        ...

    @overload
    def get_agent_task_step(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        step_id: Annotated[StrictStr, Field(..., description="ID of the step")],
        async_req: Optional[bool] = True,
        **kwargs,
    ) -> Step:  # noqa: E501
        ...

    @validate_arguments
    def get_agent_task_step(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        step_id: Annotated[StrictStr, Field(..., description="ID of the step")],
        async_req: Optional[bool] = None,
        **kwargs,
    ) -> Union[Step, Awaitable[Step]]:  # noqa: E501
        """Get details about a specified task step.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_agent_task_step(task_id, step_id, async_req=True)
        >>> result = thread.get()

        :param task_id: ID of the task (required)
        :type task_id: str
        :param step_id: ID of the step (required)
        :type step_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Step
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the get_agent_task_step_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.get_agent_task_step_with_http_info(
            task_id, step_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_agent_task_step_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        step_id: Annotated[StrictStr, Field(..., description="ID of the step")],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Get details about a specified task step.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_agent_task_step_with_http_info(task_id, step_id, async_req=True)
        >>> result = thread.get()

        :param task_id: ID of the task (required)
        :type task_id: str
        :param step_id: ID of the step (required)
        :type step_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Step, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["task_id", "step_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_agent_task_step" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["task_id"]:
            _path_params["task_id"] = _params["task_id"]

        if _params["step_id"]:
            _path_params["step_id"] = _params["step_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "Step",
        }

        return self.api_client.call_api(
            "/agent/tasks/{task_id}/steps/{step_id}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def list_agent_task_artifacts(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        **kwargs,
    ) -> Any:  # noqa: E501
        ...

    @overload
    def list_agent_task_artifacts(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        async_req: Optional[bool] = True,
        **kwargs,
    ) -> Any:  # noqa: E501
        ...

    @validate_arguments
    def list_agent_task_artifacts(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        async_req: Optional[bool] = None,
        **kwargs,
    ) -> Union[Any, Awaitable[Any]]:  # noqa: E501
        """List all artifacts that have been created for the given task.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_agent_task_artifacts(task_id, async_req=True)
        >>> result = thread.get()

        :param task_id: ID of the task (required)
        :type task_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Artifact]
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the list_agent_task_artifacts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.list_agent_task_artifacts_with_http_info(
            task_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def list_agent_task_artifacts_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """List all artifacts that have been created for the given task.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_agent_task_artifacts_with_http_info(task_id, async_req=True)
        >>> result = thread.get()

        :param task_id: ID of the task (required)
        :type task_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Artifact], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["task_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_agent_task_artifacts" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["task_id"]:
            _path_params["task_id"] = _params["task_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "Artifacts",
        }

        return self.api_client.call_api(
            "/agent/tasks/{task_id}/artifacts",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def list_agent_task_steps(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        **kwargs,
    ) -> List[str]:  # noqa: E501
        ...

    @overload
    def list_agent_task_steps(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        async_req: Optional[bool] = True,
        **kwargs,
    ) -> List[str]:  # noqa: E501
        ...

    @validate_arguments
    def list_agent_task_steps(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        async_req: Optional[bool] = None,
        **kwargs,
    ) -> Union[List[str], Awaitable[List[str]]]:  # noqa: E501
        """List all steps for the specified task.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_agent_task_steps(task_id, async_req=True)
        >>> result = thread.get()

        :param task_id: ID of the task (required)
        :type task_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[str]
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the list_agent_task_steps_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.list_agent_task_steps_with_http_info(
            task_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def list_agent_task_steps_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """List all steps for the specified task.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_agent_task_steps_with_http_info(task_id, async_req=True)
        >>> result = thread.get()

        :param task_id: ID of the task (required)
        :type task_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[str], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["task_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_agent_task_steps" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["task_id"]:
            _path_params["task_id"] = _params["task_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "List[str]",
        }

        return self.api_client.call_api(
            "/agent/tasks/{task_id}/steps",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def list_agent_tasks_ids(self, **kwargs) -> List[str]:  # noqa: E501
        ...

    @overload
    def list_agent_tasks_ids(
        self, async_req: Optional[bool] = True, **kwargs
    ) -> List[str]:  # noqa: E501
        ...

    @validate_arguments
    def list_agent_tasks_ids(
        self, async_req: Optional[bool] = None, **kwargs
    ) -> Union[List[str], Awaitable[List[str]]]:  # noqa: E501
        """List all tasks that have been created for the agent.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_agent_tasks_ids(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[str]
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the list_agent_tasks_ids_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.list_agent_tasks_ids_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def list_agent_tasks_ids_with_http_info(
        self, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """List all tasks that have been created for the agent.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_agent_tasks_ids_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[str], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = []
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_agent_tasks_ids" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "List[str]",
        }

        return self.api_client.call_api(
            "/agent/tasks",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def upload_agent_task_artifacts(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        file: Annotated[
            Union[StrictBytes, StrictStr], Field(..., description="File to upload.")
        ],
        relative_path: Annotated[
            Optional[StrictStr],
            Field(
                description="Relative path of the artifact in the agent's workspace."
            ),
        ] = None,
        **kwargs,
    ) -> Artifact:  # noqa: E501
        ...

    @overload
    def upload_agent_task_artifacts(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        file: Annotated[
            Union[StrictBytes, StrictStr], Field(..., description="File to upload.")
        ],
        relative_path: Annotated[
            Optional[StrictStr],
            Field(
                description="Relative path of the artifact in the agent's workspace."
            ),
        ] = None,
        async_req: Optional[bool] = True,
        **kwargs,
    ) -> Artifact:  # noqa: E501
        ...

    @validate_arguments
    def upload_agent_task_artifacts(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        file: Annotated[
            Union[StrictBytes, StrictStr], Field(..., description="File to upload.")
        ],
        relative_path: Annotated[
            Optional[StrictStr],
            Field(
                description="Relative path of the artifact in the agent's workspace."
            ),
        ] = None,
        async_req: Optional[bool] = None,
        **kwargs,
    ) -> Union[Artifact, Awaitable[Artifact]]:  # noqa: E501
        """Upload an artifact for the specified task.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.upload_agent_task_artifacts(task_id, file, relative_path, async_req=True)
        >>> result = thread.get()

        :param task_id: ID of the task (required)
        :type task_id: str
        :param file: File to upload. (required)
        :type file: bytearray
        :param relative_path: Relative path of the artifact in the agent's workspace.
        :type relative_path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Artifact
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the upload_agent_task_artifacts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.upload_agent_task_artifacts_with_http_info(
            task_id, file, relative_path, **kwargs
        )  # noqa: E501

    @validate_arguments
    def upload_agent_task_artifacts_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(..., description="ID of the task")],
        file: Annotated[
            Union[StrictBytes, StrictStr], Field(..., description="File to upload.")
        ],
        relative_path: Annotated[
            Optional[StrictStr],
            Field(
                description="Relative path of the artifact in the agent's workspace."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Upload an artifact for the specified task.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.upload_agent_task_artifacts_with_http_info(task_id, file, relative_path, async_req=True)
        >>> result = thread.get()

        :param task_id: ID of the task (required)
        :type task_id: str
        :param file: File to upload. (required)
        :type file: bytearray
        :param relative_path: Relative path of the artifact in the agent's workspace.
        :type relative_path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Artifact, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["task_id", "file", "relative_path"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_agent_task_artifacts" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["task_id"]:
            _path_params["task_id"] = _params["task_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        if _params["file"]:
            _files["file"] = _params["file"]

        if _params["relative_path"]:
            _form_params.append(("relative_path", _params["relative_path"]))

        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["multipart/form-data"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "Artifact",
        }

        return self.api_client.call_api(
            "/agent/tasks/{task_id}/artifacts",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

```