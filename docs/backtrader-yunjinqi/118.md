# 【TWS API 使用教程 4】---如何使用 TWS API 在盈透证券中设置 order？

> 原文：<https://yunjinqi.blog.csdn.net/article/details/122141992>

在原先对 TWS API 翻译的文章中，有两篇是专门讲解各种类型的 order 的，讲解的非常全，但是难懂，适合作为参考文献经常查漏补缺，而不适合作为一个教程。

[8、IB 和 TWS API 中的一些基本 order](https://yunjinqi.blog.csdn.net/article/details/121733665)
[9、IB 和 TWS API 中的一些高级 order](https://yunjinqi.blog.csdn.net/article/details/121733869)

#### 如何设置 order

在 TWS API 中，order 是一个 order 类的一个实例，使用的时候，首先从 ibapi.order 中 import Order
`from ibapi.order import Order`

然后对 Order 类进行初始化，形成一个实例，然后设置具体的信息。在设置订单的时候，没有指定具体的 contract，contract 是在下单的时候指定的，这样 contract 和 order 都可以进行复用。

```py
order = Order()
order.action = “BUY”
order.totalQuantity = 100
order.orderType = "MKT" 
```

#### order 中可以设置哪些信息

不同的 order 类型，携带的信息是不同的，这里尝试对绝大多数的可以设置的信息进行一个汇总，然后在下个环节对每种不同的订单类型进行举例。为了介绍上的方便，直接使用 ibapi 中的 order 类，并对其属性进行介绍分析。

```py
from ibapi.common import UNSET_INTEGER, UNSET_DOUBLE, UNSET_DECIMAL
from ibapi.object_implem import Object
from ibapi.softdollartier import SoftDollarTier

# enum Origin
(CUSTOMER, FIRM, UNKNOWN) = range(3)

# enum AuctionStrategy
(AUCTION_UNSET, AUCTION_MATCH,
 AUCTION_IMPROVEMENT, AUCTION_TRANSPARENT) = range(4)

class OrderComboLeg(Object):
    def __init__(self):
        self.price = UNSET_DOUBLE  # type: float

    def __str__(self):
        return "%f" % self.price

class Order(Object):
    def __init__(self):
        self.softDollarTier = SoftDollarTier("", "", "")
        # order identifier
        self.orderId  = 0
        self.clientId = 0
        self.permId   = 0

        # main order fields
        # order 具有的主要的字段，包括 action、totalQuantity、orderType、lmtPrice、auxPrice
        # action 是订单的方向，字符串，具有两个值，"BUY"(开多或者平空)和"SELL"(开空或者平多)
        self.action = ""
        # totalQuantity 代表 order 交易的量，小数
        self.totalQuantity = UNSET_DECIMAL
        # orderType 代表着 order 的类型，字符串，比如限价单"LMT",市价单"MKT",特别重点,这个参数的值详细注释下
        # 市价单部分包括下面的种类
        # - MKT  市价单,以当前价格成交
        # - MOC 收盘价市价单,尽可能以收盘价执行的订单
        # - MIT 达到市价成交单(Market if Touched),达到指定价格(或者更优于的价格)的时候下市价成交,使用 aucPirce 设定指定价格
        # - MKT PRT 有保护的市价单(Market with Protection),如果市价单没有立即成交,会立即把整个订单撤掉,下一个限价单,
        #              限价单价格是当卖出的时候比卖出价高一点,买入的时候比买入价低一点,以上是 TWS API 上的说法.有其他说法是不成交就取消订单
        #              而不是下限价单,需要检验下这两个说法哪个正确.
        # - MTL 市价单不成交转换成限价单(Market to Limit),如果市价单不能完全成交的话,没有成交的部分,以市价单的价格转换成限价单
        # - MKT tif = "OPG",以开盘价成交的订单,下一个市价单,但是成交时间是在下个 bar 的开盘,可能需要额外设置 outsideRth=True
        # - BOX TOP 和 MTL 很相似,仅仅用于 BOX 订单中
        # 限价单部分包含的种类
        # - LMT 限价单(Limit),以 lmtPrice 或者更优的价格成交
        # - LOC 收盘限价单(Limit on Close),收盘的时候,如果收盘价等于或者优于限价单,将会成交
        # - LIT 达到限价成交单(Limit if Touched) 达到指定价格,下限价单,指定价格用 auxPrice,限价用 lmtPrice
        # - LMT tif = "OPG",在下个 bar 开盘的时候下一个限价单,限价用 lmtPrice
        # 止损单部分包含的种类
        # - STP 止损单(Stop),止损价达到之后下一个市价单成交.使用 auxPrice 设定止损价
        # - STP LMT 限价止损单(Stop Limit),止损价达到之后,下一个限价单等待成交.使用 auxPrice 设定止损价,使用 lmtPrice 设定限价单的价格
        # - STP PRT 有保护的止损单(Stop with Protection),如果达到止损价之后,一下子成交了,和普通的止损单一样,
        #            如果部分成交,会把没有成交的部分撤掉,下一个限价单
        # 移动止损单包含的种类
        # 官网关于止损单的解释:https://www.interactivebrokers.com/en/index.php?f=605
        # - TRAIL 移动止损单(Trailing Stop),当达到止损价格的时候,下一个市价单.止损价格会根据 trailStopPrice 或者 trailingPercent 计算得到
        # - TRAIL LIMIT 移动止损限价单(Trailing Stop Limit),当市场价达到止损价的时候,下一个限价单用于止损.在移动止损单的基础之上,
        #               需要额外设置一个 lmtPrice,用于设定下限价单的价格
        # - TRAIL LIT 移动止损达到指定价格下限价成交单(Trailing Stop Limit if Touched),
        #               当市场价达到止损价之后,下一个达到指定价格下限价单等待成交.在目前版本的 API 中，没有找到例子
        # - TRAIL MIT 移动止损达到指定价格下市价成交单(Trailing Stop Market if Touched),当市场价达到止损价之后,
        #               下一个达到指定价格下市价单。在目前版本的 API 中，没有找到例子
        # 盯住类订单包含的种类
        # - PEG MKT 盯住市场(Pegged To Market) 随着市场上最好的卖价或者买价的价格而不断变动的订单价格
        # - PEG MID 盯住中间价(Pegged To Midpoint) 随着市场上最好的卖价或者买价的平均价而不断变动的订单价格
        # - PEG BENCH 盯住基准(Pegged To Benchmark) 随着市场上另一交易品种价格而不断变动的订单价格
        # - PEG STK 盯住股票(Pegged To Stock) 随着市场上股票价格而不断变动的订单价格,仅用于 box
        # - REL 相对订单(Pegged To Primary)  比 NBBO 更激进的订单价格
        # - PASSV REL 保守的相对订单(Passive Relative) 比 NBBO 更保守的订单价格

        self.orderType = ""
        # lmtPrice 代表着限定的价格，在限价单等订单类型中使用
        self.lmtPrice      = UNSET_DOUBLE
        # 在很多的订单类型中使用的扩展的价格
        self.auxPrice      = UNSET_DOUBLE

        # extended order fields
        # 一些扩展的订单类型
        # tif 代表着订单的有效期，比如 DAY,GTC 等，这个字段挺重要的，终点分析一下
        # - DAY 代表着订单在当日有效
        # - DTC 代表着订单经过一天会被沉睡，但是没有取消
        # - IOC 代表着撤销订单中没有立即成交的那部分
        # - FOK 代表着如果订单没有立即完全成交，就撤销整个订单
        # - GTC 代表着订单在撤销前都是有效的
        # - GTD 代表着订单的有效期是被 goodTillDate 字段决定的
        # - OPG 代表着订单会在开盘的时候被执行,可以在交易时间之外下单,需要设置 outsideRth 为 True
        # - AUC 代表着集合竞价订单
        self.tif = ""                # "Time in Force" - DAY, GTC, etc.
        # 当 tif 设置为 GTC 的时候,activeStartTime 代表着 订单开始的时间
        self.activeStartTime = ""   # for GTC orders
        # 当 tif 设置为 GTC 的时候,activeStopTime 代表着 订单结束的时间
        self.activeStopTime = ""    # for GTC orders
        # 用于设置 OCA 订单组的名称,订单中有这个名称的订单就会被当成一个,如果一个成交了,将会导致其他的取消
        self.ocaGroup = ""          # one cancels all group name
        # 用于设置当 OCA 订单组中,一个订单部分成交的时候的行为.1 代表着其他的会被取消;2 代表着其他的会被减少量;
        #                      3 代表着其他的会被减少量,不同订单的执行是同时的,速度会快一些,但是可能导致成交几个订单
        self.ocaType        = 0     # 1 = CANCEL_WITH_BLOCK, 2 = REDUCE_WITH_BLOCK, 3 = REDUCE_NON_BLOCK
        self.orderRef       = ""
        # TWS 是否把订单发送到服务器中
        self.transmit       = True  # if false, order will be created but not transmited
        # 父订单号，用于附加的订单跟踪究竟附加到哪个订单上使用
        self.parentId       = 0     # Parent order Id, to associate Auto STP or TRAIL orders with the original order.
        # 大宗交易的订单，设置成 True 的时候，代表着这个订单是大宗交易，需要使用特定的算法用于减少市场冲击
        self.blockOrder     = False
        #  Sweep to Fill 订单专用，是否立即以最优的价格执行成交.(据说仅仅用于交易所指定为 SMART 的时候)
        self.sweepToFill    = False
        self.displaySize    = 0
        self.triggerMethod  = 0     # 0=Default, 1=Double_Bid_Ask, 2=Last, 3=Double_Last, 4=Bid_Ask, 7=Last_or_Bid_Ask, 8=Mid-point
        # outsideRth 代表着 是否可以在交易时间之外下单
        self.outsideRth     = False
        self.hidden         = False

        # 代表着在这个时间之后订单才会被激活
        self.goodAfterTime       = ""   # Format: 20060505 08:00:00 {time zone}
        # goodTillDate 代表着 在特定时间点之前订单是有效的
        self.goodTillDate        = ""   # Format: 20060505 08:00:00 {time zone}
        self.rule80A             = ""   # Individual = 'I', Agency = 'A', AgentOtherMember = 'W', IndividualPTIA = 'J', AgencyPTIA = 'U', AgentOtherMemberPTIA = 'M', IndividualPT = 'K', AgencyPT = 'Y', AgentOtherMemberPT = 'N'
        # 代表着 全部成交或者取消
        self.allOrNone      = False
        self.minQty         = UNSET_INTEGER  # type: int
        self.percentOffset  = UNSET_DOUBLE  # type: float  # REL orders only
        self.overridePercentageConstraints = False
        # trailStopPrice  代表着移动止损订单中的止损距离
        self.trailStopPrice = UNSET_DOUBLE  # type: float
        # trailingPercent 代表着移动止损订单中的止损比例
        self.trailingPercent = UNSET_DOUBLE # type: float  # TRAILLIMIT orders only

        # financial advisors only
        self.faGroup              = ""
        self.faProfile            = ""
        self.faMethod             = ""
        self.faPercentage         = ""

        # institutional (ie non-cleared) only
        self.designatedLocation = "" #used only when shortSaleSlot=2
        self.openClose     = ""     # O=Open, C=Close
        self.origin        = CUSTOMER  # 0=Customer, 1=Firm
        self.shortSaleSlot = 0         # type: int  # 1 if you hold the shares, 2 if they will be delivered from elsewhere.  Only for Action=SSHORT
        self.exemptCode    = -1

        # SMART routing only
        # 用于给限价单增加一定的范围，增加限价单可以成交的范围，仅用于交易所设定为 SMART 的时候
        self.discretionaryAmt = 0
        self.optOutSmartRouting = False

        # BOX exchange orders only
        # 用于 auction limit 订单中，用于设定 auction 的策略
        self.auctionStrategy = AUCTION_UNSET # type: int  # AUCTION_MATCH, AUCTION_IMPROVEMENT, AUCTION_TRANSPARENT
        # startingPrice 代表 初始的订单价格
        self.startingPrice   = UNSET_DOUBLE   # type: float
        # stockRefPrice 代表着 如果基准是股票,需要达到这个价格才会开始监控
        self.stockRefPrice   = UNSET_DOUBLE   # type: float
        # delta 值，用于 Pegged to Stock 中确定订单的价格
        self.delta           = UNSET_DOUBLE   # type: float

        # pegged to stock and VOL orders only
        # stockRangeLower 代表着 如果基准是股票,监控的最低价格,低于这个价格将不会监控
        self.stockRangeLower = UNSET_DOUBLE   # type: float
        # stockRangeUpper 代表着 如果基准是股票,监控的最高价格,高于这个价格将不会监控
        self.stockRangeUpper = UNSET_DOUBLE   # type: float

        self.randomizePrice = False
        self.randomizeSize = False

        # VOLATILITY ORDERS ONLY
        # volatility  代表着计算波动率订单价格使用的波动率的百分比
        self.volatility            = UNSET_DOUBLE  # type: float
        # volatilityType 代表着 波动率订单使用的波动率的类型
        self.volatilityType        = UNSET_INTEGER  # type: int  # 1=daily, 2=annual
        self.deltaNeutralOrderType = ""
        self.deltaNeutralAuxPrice  = UNSET_DOUBLE  # type: float
        self.deltaNeutralConId     = 0
        self.deltaNeutralSettlingFirm = ""
        self.deltaNeutralClearingAccount = ""
        self.deltaNeutralClearingIntent = ""
        self.deltaNeutralOpenClose = ""
        self.deltaNeutralShortSale = False
        self.deltaNeutralShortSaleSlot = 0
        self.deltaNeutralDesignatedLocation = ""
        self.continuousUpdate      = False
        self.referencePriceType    = UNSET_INTEGER  # type: int  # 1=Average, 2 = BidOrAsk

        # COMBO ORDERS ONLY
        self.basisPoints     = UNSET_DOUBLE  # type: float  # EFP orders only
        self.basisPointsType = UNSET_INTEGER  # type: int  # EFP orders only

        # SCALE ORDERS ONLY
        self.scaleInitLevelSize  = UNSET_INTEGER  # type: int
        self.scaleSubsLevelSize  = UNSET_INTEGER  # type: int
        self.scalePriceIncrement = UNSET_DOUBLE  # type: float
        self.scalePriceAdjustValue = UNSET_DOUBLE  # type: float
        self.scalePriceAdjustInterval = UNSET_INTEGER  # type: int
        self.scaleProfitOffset = UNSET_DOUBLE  # type: float
        self.scaleAutoReset = False
        self.scaleInitPosition = UNSET_INTEGER   # type: int
        self.scaleInitFillQty = UNSET_INTEGER    # type: int
        self.scaleRandomPercent = False
        self.scaleTable = ""

        # HEDGE ORDERS
        # 对冲订单的类型
        self.hedgeType             = "" # 'D' - delta, 'B' - beta, 'F' - FX, 'P' - pair
        self.hedgeParam            = "" # 'beta=X' value for beta hedge, 'ratio=Y' for pair hedge

        # Clearing info
        self.account               = "" # IB account
        self.settlingFirm          = ""
        self.clearingAccount       = ""   #True beneficiary of the order
        self.clearingIntent        = "" # "" (Default), "IB", "Away", "PTA" (PostTrade)

        # ALGO ORDERS ONLY
        self.algoStrategy          = ""

        self.algoParams            = None    #TagValueList
        # 组合订单的时候设定的订单的方法 ，可以参考 TWS API 中的例子
        self.smartComboRoutingParams = None  #TagValueList

        self.algoId = ""

        # What-if
        # TWS 是否用提供交易的佣金或者保证金的信息代替立即发送订单到服务器
        self.whatIf = False

        # Not Held
        # TWS 是否在 IB 的订单薄中 hold 订单,如果是 True,将会放到 IB order book 中,将不会被执行
        self.notHeld = False
        self.solicited = False

        # models
        self.modelCode = ""

        # order combo legs
        # 组合订单的 leg 设置，用于 Combo Limit with Price per Leg 订单
        self.orderComboLegs = None  # OrderComboLegListSPtr

        self.orderMiscOptions = None  # TagValueList

        # VER PEG2BENCH fields:
        # peg to benchmark 订单设定的变量
        # referenceContractId 代表着 peg to benchmark order 盯住的基准合约
        self.referenceContractId = 0
        # peggedChangeAmount 代表着 peg to benchmark order 中当基准合约的价格变化大于了 referenceChangeAmount 的时候调整的 order price 的量
        self.peggedChangeAmount = 0.
        # isPeggedChangeAmount 代表着 peg to benchmark order 中盯住的订单价格的变化是导致 order price 价格的增加还是减少
        self.isPeggedChangeAmountDecrease = False
        # referenceChangeAmount 代表着 peg to benchmark order 盯住的基准合约需要调整的价格
        self.referenceChangeAmount = 0.
        # referenceExchangeId 代表着 peg to benchmark order 盯住的基准合约所在的交易所
        self.referenceExchangeId = ""
        # 调整订单的类型，比如，设置成 STP，当条件被触发之后，将会调整订单为 STP
        self.adjustedOrderType = ""

        # 当触发价格达到的时候
        self.triggerPrice = UNSET_DOUBLE
        # 调整为 STP 订单的时候，止损价设置的价位
        self.adjustedStopPrice = UNSET_DOUBLE
        # 当转换成的止损订单类型为"STP LMT"的时候，止损被触发之后，下的限价单的价格
        self.adjustedStopLimitPrice = UNSET_DOUBLE
        # 当调整为"TRAIL"订单之后，移动止损的量
        self.adjustedTrailingAmount = UNSET_DOUBLE
        # 当调整为"TRAIL"订单之后，移动止损的 amount 或者 percent，TWS API 这样解释，有点绕
        self.adjustableTrailingUnit = 0
        self.lmtPriceOffset = UNSET_DOUBLE

        self.conditions = []  # std::vector<std::shared_ptr<OrderCondition>>
        self.conditionsCancelOrder = False
        self.conditionsIgnoreRth = False

        # ext operator
        self.extOperator = ""

        # native cash quantity
        # Forex Cash Quantity Order 订单使用
        self.cashQty = UNSET_DOUBLE

        self.mifid2DecisionMaker = ""
        self.mifid2DecisionAlgo = ""
        self.mifid2ExecutionTrader = ""
        self.mifid2ExecutionAlgo = ""

        self.dontUseAutoPriceForHedge = False

        self.isOmsContainer = False

        self.discretionaryUpToLimitPrice = False

        self.autoCancelDate = ""
        self.filledQuantity = UNSET_DECIMAL
        self.refFuturesConId = 0
        self.autoCancelParent = False
        self.shareholder = ""
        self.imbalanceOnly = False
        self.routeMarketableToBbo = False
        self.parentPermId = 0

        self.usePriceMgmtAlgo = None
        self.duration = UNSET_INTEGER
        self.postToAts = UNSET_INTEGER

    def __str__(self):
        s = "%s,%d,%s:" % (self.orderId, self.clientId, self.permId)

        s += " %s %s %d@%f" % (
            self.orderType,
            self.action,
            self.totalQuantity,
            self.lmtPrice)

        s += " %s" % self.tif

        if self.orderComboLegs:
            s += " CMB("
            for leg in self.orderComboLegs:
                s += str(leg) + ","
            s += ")"

        if self.conditions:
            s += " COND("
            for cond in self.conditions:
                s += str(cond) + ","
            s += ")"

        return s 
```

[最新的注释可以在下面的网址中找到。](https://gitee.com/yunjinqi/ibapi)

#### 一些 order 的例子

*   ##### Market order

A [Market](https://www.interactivebrokers.com/en/index.php?f=602) order 是以市场买入价或卖出价买入或卖出的订单。市价单可能会增加成交的可能性和执行速度，但与限价单不同，市价单不提供价格保护，并且可能以远低于/高于当前显示的买入价/卖出价的价格成交。

​ 支持的产品: BOND, CFD, EFP, CASH, FUND, FUT, FOP, OPT, STK, WAR

支持的交易所：[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=mkt)

```py
order = Order()
order.action = action
order.orderType = "MKT"
order.totalQuantity = quantity 
```

*   ##### Market On Close

A [Market On Close](https://www.interactivebrokers.com/en/index.php?f=599) (MOC) order 是为尽可能接近收盘价而提交的市场订单。

支持的产品: CFD, FUT, STK, WAR

支持的交易所：[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=moc)

```py
order = Order()
order.action = action
order.orderType = "MOC"
order.totalQuantity = quantity 
```

*   ##### Market If Touched

A [Market If Touched](https://www.interactivebrokers.com/en/index.php?f=600) (MIT) 是是购买（或出售）低于（或高于）市场的合约的订单。其目的是利用股票或其他价格的突然或意外变化，并为投资者提供触发价格以启动订单。投资者可能正在等待过度强弱（或疲软）停止，这可能由特定价格点表示。一旦达到特定价格水平，MIT 订单可用于确定是否进入市场。此订单在系统中保留，直到触及触发价格，然后作为市场订单提交。MIT 订单类似于止损订单，不同之处在于 MIT 卖出订单高于当前市场价格，止损卖出订单位于下方

​ 支持的产品: BOND, CFD, CASH, FUT, FOP, OPT, STK, WAR

​ 支持的交易所：[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=mit)

```py
order = Order()
order.action = action
order.orderType = "MIT"
order.totalQuantity = quantity
order.auxPrice = price 
```

*   ##### Market with Protection

此订单类型对于使用 Globex 的期货交易者非常有用。A [Market with Protection](https://www.interactivebrokers.com/en/index.php?f=601) order 是一个市价单，如果整个订单没有立即以市场价格执行，它将被取消并重新提交为限价单。Globex 将限价设置为接近当前市场价格，卖出订单略高，买入订单略低。

​ 支持的产品: FUT, FOP

​ 支持的交易所:[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=mktprot)

```py
order = Order()
order.action = action
order.orderType = "MKT PRT"
order.totalQuantity = quantity 
```

*   ##### Market to Limit

A [Market-to-Limit](https://www.interactivebrokers.com/en/index.php?f=597) (MTL) 以市价单提交，以当前最佳市场价格执行。如果订单仅部分成交，则订单的其余部分将被取消并重新提交为限价订单，其限价等于订单执行已成交部分的价格。

​ 支持的产品: CFD, FUT, FOP, OPT, STK, WAR

​ 支持的交易所：[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=mtl)

```py
order = Order()
order.action = action
order.orderType = "MTL"
order.totalQuantity = quantity 
```

*   ##### Market On Open

A [Market On Open](https://www.interactivebrokers.com/en/index.php?f=598) (MOO) 在有效的 OPG 时间下一个市价单，以创建在市场开盘时自动提交并以市场价格成交的订单。以开盘价成交的订单,下一个市价单,但是成交时间是在下个 bar 的开盘,可能需要额外设置 outsideRth=True。在下面的例子中，没有看到 outsideRth 这个属性的值。

​ 支持的产品: CFD, FUT, STK, WAR

​ 支持的交易所：[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=moo)

```py
order = Order()
order.action = action
order.orderType = "MKT"
order.totalQuantity = quantity
order.tif = "OPG" 
```

*   ##### Box Top

A [Box Top](https://www.interactivebrokers.com/en/index.php?f=582) order 以当前最优惠价格作为市场订单执行。如果订单仅部分成交，则剩余部分将作为限价订单提交，其限价等于订单执行已成交部分的价格。

​ 支持的产品: OPT (BOX only)

```py
order = Order()
order.action = action
order.orderType = "BOX TOP"
order.totalQuantity = quantity 
```

*   ##### Limit Order

A [Limit order](https://www.interactivebrokers.com/en/index.php?f=593) 以指定价格或更好的价格买入或卖出的订单。限价订单确保如果订单成交，它不会以劣于您的限价的价格成交，但它不保证成交。

​ 支持的产品: BOND, CFD, CASH, FUT, FOP, OPT, STK, WAR

​ 支持的交易所：[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=lmt)

```py
order = Order()
order.action = action
order.orderType = "LMT"
order.totalQuantity = quantity
order.lmtPrice = limitPrice 
```

*   ##### Limit on Close

A [Limit-on-close](https://www.interactivebrokers.com/en/index.php?f=591) (LOC) order 在收盘时提交，如果收盘价优于提交的限价，则将执行。

​ 支持的产品: CFD, FUT, STK, WAR

​ 支持的交易所：[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=loc)

```py
order = Order()
order.action = action
order.orderType = "LOC"
order.totalQuantity = quantity
order.lmtPrice = limitPrice 
```

*   ##### Limit if Touched

A [Limit if Touched](https://www.interactivebrokers.com/en/index.php?f=592) order 是以低于（或高于）市场的指定价格或更好的价格买入（或卖出）合约的订单。此订单在系统中保留，直到触及触发价格。LIT 订单类似于止损限价订单，不同之处在于 LIT 卖出订单高于当前市场价格，而止损限价卖出订单位于下方。

​ 支持的产品: BOND, CFD, CASH, FUT, FOP, OPT, STK, WAR

​ 支持的交易所：[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=lit)

```py
order = Order()
order.action = action
order.orderType = "LIT"
order.totalQuantity = quantity
order.lmtPrice = limitPrice
order.auxPrice = triggerPrice 
```

*   ##### Limit on Open

A [Limit-on-Open](https://www.interactivebrokers.com/en/index.php?f=590) (LOO) order 将在有效的 OPG 时间下一个限价单，以创建在市场开盘时提交的订单，并且该订单只会以指定的限价或更好的价格执行。订单根据特定的交换规则填写。

​ 支持的产品: CFD, STK, OPT, WAR

​ 支持的交易所：[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=moo)

```py
order = Order()
order.action = action
order.tif = "OPG"
order.orderType = "LMT"
order.totalQuantity = quantity
order.lmtPrice = limitPrice 
```

*   Stop

A [Stop](https://www.interactivebrokers.com/en/index.php?f=609) order 在达到或穿透用户指定的止损触发价格时提交买入或卖出市场订单的指令。止损订单不能保证特定的执行价格，并且可能大大偏离其止损价格执行。卖出止损订单始终低于当前市场价格，通常用于限制多头股票头寸的损失或保护利润。买入止损订单总是高于当前市场价格。它通常用于限制损失或帮助保护卖空的利润。

​ 支持的产品: CFD, BAG, CASH, FUT, FOP, OPT, STK, WAR

​ 支持的交易所:[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=stp)

```py
order = Order()
order.action = action
order.orderType = "STP"
order.auxPrice = stopPrice
order.totalQuantity = quantity 
```

*   ##### Stop Limit

A [Stop-Limit](https://www.interactivebrokers.com/en/index.php?f=608) order 在达到或穿透用户指定的止损触发价格时提交买入或卖出限价单的指令。订单有两个基本组成部分：止损价和限价。当交易以止损价或通过止损价发生时，订单变得可执行并作为限价单进入市场，即以指定价格或更好的价格买入或卖出的订单。

​ 支持的产品: CFD, CASH, FUT, FOP, OPT, STK, WAR

​ 支持的交易所:[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=stplmt)

```py
order = Order()
order.action = action
order.orderType = "STP LMT"
order.totalQuantity = quantity
order.lmtPrice = limitPrice
order.auxPrice = stopPrice 
```

*   ##### Stop with Protection

A [Stop with Protection](https://www.interactivebrokers.com/en/index.php?f=3077) order 将止损限价单的功能与带有保护订单的市场相结合。订单设置为以指定的止损价格触发。当止损价被穿透时，订单被触发为具有保护令的市价单，这意味着它将在等于触发价格+/-交易所定义的保护点形成的范围内成交。未在此受保护范围内成交的订单的任何部分将作为限价订单以交易所定义的触发价格+/-保护点提交。

​ 支持的产品: FUT

​ 支持的交易所:[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=stpprot)

```py
order = Order()
order.totalQuantity = quantity
order.action = action
order.orderType = "STP PRT"
order.auxPrice = stopPrice 
```

*   ##### Trailing Stop

A sell [trailing stop](https://www.interactivebrokers.com/en/index.php?f=605) order 将止损价格设置为低于市场价格的固定金额，并附加"追踪"金额。随着市场价格的上涨，止损价按跟踪金额上涨，但如果股票价格下跌，止损价格不会改变，当止损价格被击中时，将提交市价单。这种技术旨在允许投资者指定最大可能损失的限制，而不对最大可能收益设置限制。"买入"追踪止损订单是卖出追踪止损订单的镜像，最适合用于下跌市场。

请注意，追踪止损订单可以将追踪金额指定为百分比（如下例所示），也可以指定为在 auxPrice 字段中指定的绝对金额。

​ 支持的产品: CFD, CASH, FOP, FUT, OPT, STK, WAR

​ 支持的交易所:[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=trail)

```py
order = Order()
order.action = action
order.orderType = "TRAIL"
order.totalQuantity = quantity
order.trailingPercent = trailingPercent
order.trailStopPrice = trailStopPrice 
```

*   ###### Trailing Stop Limit

A [trailing stop limit](https://www.interactivebrokers.com/en/index.php?f=606) order 旨在允许投资者指定最大可能损失的限制，而无需对最大可能收益设置限制。卖出追踪止损限值随市场价格移动，并根据用户定义的"追踪"金额，以低于市场价格的固定金额不断重新计算止损触发价格。限价订单价格也会根据限价偏移量不断重新计算。随着市场价格的上涨，止损价和限价的上涨分别抵消了追踪金额和限价，但如果股票价格下跌，止损价格保持不变，当止损价达到时，将以最后计算的限价提交限价单。"买入"追踪止损限价单是卖出追踪止损限价的镜像，通常用于下跌的市场。

追踪止损限价订单可以指定为绝对金额的追踪金额（如下例所示）发送，也可以在追踪百分比字段中指定。

**重要提示："**限制偏移量"字段默认在 v963+ 的 TWS/IBG 设置中设置。此设置需要在订单预设、接受的默认值或从 API 发送的限价偏移量中更改，如下面的示例所示。并非同时在 TRAIL 限价订单中设置"限价"和"限价偏移量"字段。

​ 支持的产品: BOND, CFD, CASH, FUT, FOP, OPT, STK, WAR

```py
order = Order()
order.action = action
order.orderType = "TRAIL LIMIT"
order.totalQuantity = quantity
order.trailStopPrice = trailStopPrice
order.lmtPriceOffset = lmtPriceOffset
order.auxPrice = trailingAmount 
```

##### Pegged to Market

A [pegged-to-market order](https://www.interactivebrokers.com/en/index.php?f=616) 旨在获得相对于全国最佳报价（NBO）的买入价格或相对于全国最佳出价（NBB）的卖出价格。根据报价的宽度，此订单可能是被动的或主动的。交易者通过输入限价来创建订单，该限价定义了他们愿意接受的最差限价。接下来，交易者输入一个抵消金额，该金额计算活动限价如下：卖出订单价格= 买入价+ 抵消金额 买入订单价格 = 卖出价 - 抵消金额

支持的产品: STK

支持的交易所：[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=pegmkt)

```py
order = Order()
order.action = action
order.orderType = "PEG MKT"
order.totalQuantity = quantity
order.auxPrice = marketOffset#Offset price 
```

*   ##### Pegged to Midpoint

A [pegged-to-midpoint](https://www.interactivebrokers.com/en/index.php?f=1058) order 为交易者提供了一种在全国最佳买入价和卖出价（NBBO）的中间价寻求价格的方法。随着市场的移动，价格会自动调整以固定到中间价，以保持主动。对于买入订单，您的出价与 NBBO 中间价挂钩，如果市场波动，订单价格会自动调整以继续挂钩中间价。价格只会调整为更具主动性。如果市场朝相反的方向移动，订单将执行。

​ 支持的产品： STK

​ 支持的交易所：[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=pegmid)

```py
order = Order()
order.action = action
order.orderType = "PEG MID"
order.totalQuantity = quantity
order.auxPrice = offset
order.lmtPrice = limitPrice 
```

*   ##### Pegged to Benchmark

The [Pegged to Benchmark](https://www.interactivebrokers.com/en/index.php?f=7100) order 类似于期权的挂钩股票订单，不同之处在于挂钩到基准允许您指定任何资产类型作为股票或期权订单的参考（基准）合约。主要合约和参考合约必须使用相同的货币。

​ 支持的产品:STK, OPT

​ 支持的交易所:[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=pegbench)

```py
order = Order()
order.orderType = "PEG BENCH"
#BUY or SELL
order.action = action
order.totalQuantity = quantity
#Beginning with price...
order.startingPrice = startingPrice
#increase/decrease price..
order.isPeggedChangeAmountDecrease = peggedChangeAmountDecrease
#by... (and likewise for price moving in opposite direction)
order.peggedChangeAmount = peggedChangeAmount
#whenever there is a price change of...
order.referenceChangeAmount = referenceChangeAmount
#in the reference contract...
order.referenceContractId = referenceConId
#being traded at...
order.referenceExchange = referenceExchange
#starting reference price is...
order.stockRefPrice = stockReferencePrice
#Keep order active as long as reference contract trades between...
order.stockRangeLower = referenceContractLowerRange
#and...
order.stockRangeUpper = referenceContractUpperRange 
```

*   ##### Pegged to Stock

A [Pegged to Stock](https://www.interactivebrokers.com/en/index.php?f=615) order 是通过用户定义 delta 值和期权标的股票价格的变化的乘积来不断调整期权订单价格。delta 作为绝对值输入，并假定看涨期权为正数，看跌期权为负数。买入或卖出看涨期权价格是通过看张期权的初始价格加上标的股票价格变化量乘以定义的 delta 来确定的。用当前的 NBBO 的中间价减去股票参考价格来确定股票的参考价格。股票参考价格可以由用户定义，或者如果没有输入参考价格，则默认为订单时的 NBBO 的中间价。您也可以输入股票价格的最高价和最低价，当股票价格超过最高价或者低于最低价时取消订单。为了让订单更有优势，delta 乘以股票价格的变化的值将被四舍五入到最接近的美分(最小报价单位)。

​ 支持的产品: OPT

​ 支持的交易所：[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=relstk)

```py
order = Order()
order.action = action
order.orderType = "PEG STK"
order.totalQuantity = quantity
order.delta = delta
order.stockRefPrice = stockReferencePrice
order.startingPrice = startingPrice 
```

*   ##### Pegged to Primary

[Relative](https://www.interactivebrokers.com/en/index.php?f=613) (a.k.a. Pegged-to-Primary) orders 为交易者提供了一种寻求比全国最佳买入价和卖出价（NBBO）更具主动性的价格的手段。通过充当流动性提供者，并发出比当前最佳出价和报价更积极的出价和报价，交易者增加了完成订单的几率。报价会随着市场的变动而自动调整，以保持主动。对于买入订单，您的出价超过 NBB 一定的偏移量，如果 NBB 向上移动，您的出价也将向上移动。如果 NBB 下跌，则不会进行任何调整，因为您的出价将变得更加主动和执行。对于卖出订单，您的报价低于 NBO 挂钩的一定偏移量，如果 NBO 向下移动，您的报价也将向下移动。如果 NBO 上升，则不会进行调整，因为您的报价将变得更加主动和执行。除了偏移量之外，您还可以定义一个绝对上限，其工作方式类似于限价，并将防止您的订单在指定水平之上或之下成交。股票、期权及期货 - 不适用于模拟交易

​ 支持的产品: CFD, STK, OPT, FUT

支持的交易所：[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=rel)

```py
order = Order()
order.action = action
order.orderType = "REL"
order.totalQuantity = quantity
order.lmtPrice = priceCap
order.auxPrice = offsetAmount 
```

*   ##### Passive Relative

[Passive Relative](https://www.interactivebrokers.com/en/index.php?f=3124) orders 为交易者提供了一种手段，可以寻求比全国最佳买入价和卖出价（NBBO）更不主动的价格，同时保持订单与最佳出价（买入）或卖价（卖出）挂钩。订单价格会随着市场的变动而自动调整，以保持订单不那么主动。对于买入订单，您的订单价格通过低于 NBB 的一定偏移量，如果 NBB 向上移动，您的出价也将上升。如果 NBB 向下移动，则不会进行任何调整，以免您的出价将变得激进并执行。对于卖出订单，您的价格通过高于 NBO 的一定偏移量，如果 NBO 向下移动，您的报价也将向下移动。如果 NBO 上升，则不会进行调整，以免您的报价将变得激进并执行。除了偏移量之外，您还可以定义一个绝对上限，其工作方式类似于限价，并将防止您的订单在指定水平之上或之下执行。被动相对顺序类似于相对/与主要挂钩顺序，不同之处在于被动相对从出价中减去偏移量，而相对值将偏移量添加到出价中。

​ 支持的产品: STK, WAR

​ 支持的交易所：[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=passvrel)

```py
order = Order()
order.action = action
order.orderType = "PASSV REL"
order.totalQuantity = quantity
order.auxPrice = offset 
```

#### 其他的一些订单类型

*   ##### Auction(类似于国内的集合竞价)

An [Auction](https://www.interactivebrokers.com/en/index.php?f=578) order 在开市前期间输入电子交易系统，以计算的开盘价（COP）执行。如果您的订单在开盘时未成交，订单将作为限价订单重新提交，限价设置为 COP 或开市后的最佳买入价/卖出价。

​ 支持的产品: FUT, STK

​ 支持的交易所：[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=auc)

```py
order = Order()
order.action = action
order.tif = "AUC"
order.orderType = "MTL"
order.totalQuantity = quantity
order.lmtPrice = price 
```

*   ##### Auction Limit

对于发送到波士顿期权交易所（BOX）的期权订单，您可以选择以美分为单位参加 BOX 的价格改善拍卖。所有 BOX 直接相关的[价格改善](https://www.interactivebrokers.com/en/index.php?f=614)订单将立即从盈透证券发送到 BOX 订单簿，当条款允许时，IB 将根据价格和交易量优先级对其进行评估，以纳入价格改善拍卖。在拍卖中，您的订单将在相同价格下将会优先于经纪交易商参与价格改善。以指定价格参与 Auction Limit order。使用限价单可确保您不会以劣于限定价格成交。以美分为增量输入限价订单，您的竞价改善金额计算为限价单价格与最接近列出的增量之间的差额（Enter limit orders in penny increments with your auction improvement amount computed as the difference between your limit order price and the nearest listed increment.）。

​ 支持的产品: OPT (BOX only)

```py
order = Order()
order.action = action
order.orderType = "LMT"
order.totalQuantity = quantity
order.lmtPrice = price
order.auctionStrategy = auctionStrategy 
```

*   ##### Auction Pegged to Stock

对于发送到波士顿期权交易所（BOX）的期权订单，您可以选择以美分为单位参加 BOX 的价格改善拍卖。所有 BOX 直接相关的[价格改善](https://www.interactivebrokers.com/en/index.php?f=614)订单将立即从盈透证券发送到 BOX 订单簿，当条款允许时，IB 将根据价格和交易量优先级对其进行评估，以纳入价格改善拍卖。在拍卖中，您的订单将在相同价格下将会优先于经纪交易商参与价格改善。An Auction Pegged to Stock order 通过用户定义 delta 值和期权标的股票价格的变化的乘积来不断调整订单价格。delta 作为绝对值输入，并假定看涨期权为正数，看跌期权为负数。买入或卖出看涨期权价格是通过看张期权的初始价格加上标的股票价格变化量乘以定义的 delta 来确定的。用当前的 NBBO 的中间价减去股票参考价格来确定股票的参考价格。股票参考价格可以由用户定义，或者如果没有输入参考价格，则默认为订单时的 NBBO 的中间价。您也可以输入股票价格的最高价和最低价，当股票价格超过最高价或者低于最低价时取消订单。为了让订单更有优势，delta 乘以股票价格的变化的值将被四舍五入到最接近的美分(最小报价单位)。

​ 支持的产品:OPT (BOX only)

```py
order = Order()
order.action = action
order.orderType = "PEG STK"
order.totalQuantity = quantity
order.delta = delta
order.startingPrice = startingPrice 
```

*   ##### Auction Relative

对于发送到波士顿期权交易所（BOX）的期权订单，您可以选择以美分为单位参加 BOX 的价格改善拍卖。所有 BOX 直接相关的[价格改善](https://www.interactivebrokers.com/en/index.php?f=614)订单将立即从盈透证券发送到 BOX 订单簿，当条款允许时，IB 将根据价格和交易量优先级对其进行评估，以纳入价格改善拍卖。在拍卖中，您的订单将在相同价格下将会优先于经纪交易商参与价格改善。An Auction Pegged to Stock order 通过用户定义 delta 值和期权标的股票价格的变化的乘积来不断调整订单价格。delta 作为绝对值输入，并假定看涨期权为正数，看跌期权为负数。买入或卖出看涨期权价格是通过看张期权的初始价格加上标的股票价格变化量乘以定义的 delta 来确定的。用当前的 NBBO 的中间价减去股票参考价格来确定股票的参考价格。股票参考价格可以由用户定义，或者如果没有输入参考价格，则默认为订单时的 NBBO 的中间价。您也可以输入股票价格的最高价和最低价，当股票价格超过最高价或者低于最低价时取消订单。为了让订单更有优势，delta 乘以股票价格的变化的值将被四舍五入到最接近的美分(最小报价单位)。

​ 支持的产品: OPT (BOX only)

```py
order = Order()
order.action = action
order.orderType = "REL"
order.totalQuantity = quantity
order.auxPrice = offset 
```

*   ##### Sweep to Fill

当交易者重视执行速度而不是价格时，[Sweep-to-fill](https://www.interactivebrokers.com/en/index.php?f=607) orders 很有用。weep-to-fill order 可识别最佳价格以及以该价格提供/可用的确切数量，并传输订单的相应部分以立即执行。同时，它确定下一个最佳价格和提供/可用数量，并提交订单的匹配数量以立即执行。

​ 支持的产品:CFD, STK, WAR (SMART only)

```py
order = Order()
order.action = action
order.orderType = "LMT"
order.totalQuantity = quantity
order.lmtPrice = price
order.sweepToFill = True 
```

*   ##### Block

The [Block](https://www.interactivebrokers.com/en/index.php?f=580) attribute 用于 ISE 上至少包含 50 个合约的大批量期权订单。要在不影响市场的情况下执行一段时间内的大批量订单，请使用[累积/分配](https://interactivebrokers.github.io/tws-api/ibalgos.html#ad)算法。

​ 支持的产品: OPT

​ 支持的交易所：[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=block)

```py
order = Order()
order.action = action
order.orderType = "LMT"
order.totalQuantity = quantity#Large volumes!
order.lmtPrice = price
order.blockOrder = True 
```

*   ##### Forex Cash Quantity Order

Forex orders 可以使用 cashQty 字段以第二种货币的面额成对下达。
Requires TWS or IBG 963+

​ 支持的产品: CASH

​ 订单说明：[Forex Cash Quantity Orders](https://www.interactivebrokers.com/en/index.php?f=23876#963-02)

```py
order = Order()
order.action = action
order.orderType = "LMT"
order.lmtPrice = limitPrice
order.cashQty = cashQty 
```

*   ##### Discretionary(百度上翻译成全权委托订单)

An [Discretionary](https://www.interactivebrokers.com/en/index.php?f=585) order 是一个 限价订单，其中有隐藏的"可自由支配"金额，可用于增加限价订单有资格执行的价格范围。市场只看到限价。

​ 支持的产品: STK

​ 支持的交易所：[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=dis)

```py
order = Order()
order.action = action
order.orderType = "LMT"
order.totalQuantity = quantity
order.lmtPrice = price
order.discretionaryAmt = discretionaryAmount 
```

*   ##### Combo Limit

创建包含期权、股票和期货产品的组合订单（如果订单通过 SmartRouting 提交，则可以包括股票）。虽然组合/点差订单是由单独的 leg 构成的，但如果直接提交到交易所，它将作为单个交易执行。对于 SmartRouted 的组合订单，每个分支可以单独执行，以确保最佳执行。

​ 支持的产品: OPT, STK, FUT

```py
order = Order()
order.action = action
order.orderType = "LMT"
order.totalQuantity = quantity
order.lmtPrice = limitPrice
if nonGuaranteed:         
      order.smartComboRoutingParams = []
      order.smartComboRoutingParams.append(TagValue("NonGuaranteed", "1")) 
```

*   ##### Combo Market

创建包含期权、股票和期货支段的组合订单（如果订单通过智能路由路由，则可以包括库存段）。虽然组合/点差订单是由单独的分支构成的，但如果直接路由到交易所，它将作为单个交易执行。对于 SmartRouted 的组合订单，每个分支可以单独执行，以确保最佳执行。

​ 支持的产品: OPT, STK, FUT

```py
order = Order()
order.action = action
order.orderType = "MKT"
order.totalQuantity = quantity
if nonGuaranteed:
    order.smartComboRoutingParams = []
	order.smartComboRoutingParams.append(TagValue("NonGuaranteed", "1")) 
```

*   ##### Combo Limit with Price per Leg

创建包含期权、股票和期货支段的组合订单（如果订单通过智能路由路由，则可以包括库存段）。虽然组合/点差订单是由单独的分支构成的，但如果直接路由到交易所，它将作为单个交易执行。对于 SmartRouted 的组合订单，每个分支可以单独执行，以确保最佳执行。

​ 支持的产品: OPT, STK, FUT

```py
order = Order()
order.action = action
order.orderType = "LMT"
order.totalQuantity = quantity
order.orderComboLegs = []
for price in legPrices:       
    comboLeg = OrderComboLeg()
    comboLeg.price = price
    order.orderComboLegs.append(comboLeg)                   
    if nonGuaranteed:             
    	order.smartComboRoutingParams = []
        order.smartComboRoutingParams.append(TagValue("NonGuaranteed", "1")) 
```

*   ##### Relative Limit Combo

创建包含期权、股票和期货支段的组合订单（如果订单通过智能路由路由，则可以包括库存段）。虽然组合/点差订单是由单独的分支构成的，但如果直接路由到交易所，它将作为单个交易执行。对于 SmartRouted 的组合订单，每个分支可以单独执行，以确保最佳执行。

​ 支持的产品: OPT, STK, FUT

```py
order = Order()
order.action = action
order.totalQuantity = quantity
order.orderType = "REL + LMT"
order.lmtPrice = limitPrice
if nonGuaranteed:        
    order.smartComboRoutingParams = []
    order.smartComboRoutingParams.append(TagValue("NonGuaranteed", "1")) 
```

*   ##### Relative Market Combo

创建包含期权、股票和期货支段的组合订单（如果订单通过智能路由路由，则可以包括库存段）。虽然组合/点差订单是由单独的分支构成的，但如果直接路由到交易所，它将作为单个交易执行。对于 SmartRouted 的组合订单，每个分支可以单独执行，以确保最佳执行。

​ 支持的产品: OPT, STK, FUT

```py
order = Order()
order.action = action
order.totalQuantity = quantity
order.orderType = "REL + MKT"
    if nonGuaranteed:

    	order.smartComboRoutingParams = []
    	order.smartComboRoutingParams.append(TagValue("NonGuaranteed", "1")) 
```

*   ##### Volatility

具体到美国期权，投资者可以创建和输入[波动性类型的](https://www.interactivebrokers.com/en/index.php?f=604)期权和组合订单，而不是价格订单。期权交易者可能希望交易和定位由其隐含波动率决定的期权价格变动。由于隐含波动率是期权溢价的关键决定因素，交易者在特定合约月份进行头寸，以利用在收益之前、期间或之后或公司特定或广泛市场波动率预期发生变化时产生的隐含波动率变化。为了创建波动率订单，客户必须首先从交易工具菜单中创建波动率交易者页面，当他们输入期权合约时，溢价将以百分比而不是溢价显示。买入/卖出过程与以溢价价格定价的常规订单相同，只是客户可以限制他们愿意支付或接收的波动水平。

​ 支持的产品:FOP, OPT

​ 支持的交易所:[Supported exchanges](https://www.interactivebrokers.com/en/index.php?f=3883?ot=volat)

```py
order = Order()
order.action = action
order.orderType = "VOL"
order.totalQuantity = quantity
order.volatility = volatilityPercent#Expressed in percentage (40%)
order.volatilityType = volatilityType# 1=daily, 2=annual 
```

#### Hedging

对冲订单和一篮子订单比较相似，当使用对冲订单的时候，当主订单被执行之后子订单才会提交。就像在 TWS 中，对冲订单可以用在外汇交易、贝塔对冲 或者 配对交易中

[Hedging Orders in TWS](https://www.interactivebrokers.com/en/software/tws/attachedordertop.htm)

以外汇对冲为例，当以基础以外的货币购买合约时，您可以附加外汇订单，将基础货币转换为合约货币，以支付交易成本，这要归功于 TWS API 的[附加订单](https://interactivebrokers.github.io/tws-api/order_submission.html#order_attach)机制。

```py
@staticmethod
def MarketFHedge(parentOrderId:int, action:str):

    #FX Hedge orders can only have a quantity of 0
    order = OrderSamples.MarketOrder(action, 0)
    order.parentId = parentOrderId
    order.hedgeType = "F"
    return order 
```

```py
# Parent order on a contract which currency differs from your base currency
parent = OrderSamples.LimitOrder("BUY", 100, 10)
parent.orderId = self.nextOrderId()
parent.transmit = False
# Hedge on the currency conversion
hedge = OrderSamples.MarketFHedge(parent.orderId, "BUY")
# Place the parent first...
self.placeOrder(parent.orderId, ContractSamples.EuropeanStock(), parent)
# Then the hedge order
self.placeOrder(self.nextOrderId(), ContractSamples.EurGbpFx(), hedge) 
```

请注意，在某些情况下，在下的主订单进行处理后，在下子订单之前，需要包括 50 毫秒或更短的延迟。否则，将触发错误"10006：缺少主订单"。

#### [Bracket Orders](https://www.interactivebrokers.com/en/index.php?f=583)

一篮子订单旨在通过创建一个在主订单上下的止盈单和止损单帮助您限制损失并锁定利润。买入订单由在订单价格上方设定一个卖出限价单和在订单价格下方设定一个卖出止损单。卖出订单反之。请注意一篮子订单如何利用 TWS API 的[附加订单](https://interactivebrokers.github.io/tws-api/order_submission.html#order_attach)机制。

要记住的一个关键点是准确处理订单传输。由于一篮子由三个订单组成，因此始终存在至少一个订单在发送整个一篮子订单之前被成交的风险。为避免这种情况，请使用[IBApi.Order.Transmit](https://interactivebrokers.github.io/tws-api/classIBApi_1_1Order.html#aaa1c4f31b9580ee0715edcd78a51cbec)标志。当此标志设置为"false"时，TWS 将接收订单，但不会将其发送（传输）到服务器。在下面的示例中，第一个（父级）和第二个（获利）订单将发送到 TWS，但不会传输到服务器。但是，当发送最后一个子订单（stopLoss）并假设其[IBApi.Order.Transmit](https://interactivebrokers.github.io/tws-api/classIBApi_1_1Order.html#aaa1c4f31b9580ee0715edcd78a51cbec)标志设置为 true 时，TWS 会将其解释为一个信号，不仅要传输其父订单，还要传输其他兄弟姐妹，从而消除意外执行的风险。

这个和 backtrader 中的一篮子订单很相似，[可以参考我的专栏文章：一篮子订单(Bracket Orders)的创建和撮合机制](https://yunjinqi.blog.csdn.net/article/details/112155378)

```py
@staticmethod
def BracketOrder(parentOrderId:int, action:str, quantity:Decimal, 
                         limitPrice:float, takeProfitLimitPrice:float, 
                          stopLossPrice:float):

   #This will be our main or "parent" order
   parent = Order()
   parent.orderId = parentOrderId
   parent.action = action
   parent.orderType = "LMT"
   parent.totalQuantity = quantity
   parent.lmtPrice = limitPrice
   #The parent and children orders will need this attribute set to False to prevent accidental executions.
   #The LAST CHILD will have it set to True, 
   parent.transmit = False

   takeProfit = Order()
   takeProfit.orderId = parent.orderId + 1
   takeProfit.action = "SELL" if action == "BUY" else "BUY"
   takeProfit.orderType = "LMT"
   takeProfit.totalQuantity = quantity
   takeProfit.lmtPrice = takeProfitLimitPrice
   takeProfit.parentId = parentOrderId
   takeProfit.transmit = False

   stopLoss = Order()
   stopLoss.orderId = parent.orderId + 2
   stopLoss.action = "SELL" if action == "BUY" else "BUY"
   stopLoss.orderType = "STP"
   #Stop trigger price
   stopLoss.auxPrice = stopLossPrice
   stopLoss.totalQuantity = quantity
   3stopLoss.parentId = parentOrderId
   #In this case, the low side order will be the last child being sent. Therefore, it needs to set this attribute to True 
   #to activate all its predecessors
   stopLoss.transmit = True 
   bracketOrder = [parent, takeProfit, stopLoss]
   return bracketOrder 
```

```py
bracket = OrderSamples.BracketOrder(self.nextOrderId(), "BUY", 100, 30, 40, 20)
for o in bracket:
    self.placeOrder(o.orderId, ContractSamples.EuropeanStock(), o)
    self.nextOrderId()  # need to advance this we'll skip one extra oid, it's fine 
```

#### [One-Cancels All](https://www.interactivebrokers.com/en/index.php?f=617)

[一个成交取消全部](https://www.interactivebrokers.com/en/index.php?f=617)（OCA）订单类型允许投资者将多个可能不相关的订单分配给一个组。其目的是只完成其中一个订单，这反过来将导致 TWS 取消剩余的订单。投资者可以提交几份订单，旨在利用集团内最理想的价格。完成一个组订单会导致取消剩余的组订单，而部分完成会导致组重新平衡。投资者可能希望出售 1000 股股票，其中只有三个头寸中的一个高于现行市场价格。OCA 订单组允许投资者在指定的目标水平输入价格，如果一个完成，其他两个将自动取消。或者，投资者可能希望在下跌的市场中持有 eMini 标准普尔指数期货的多头头寸，或者以更优惠的价格出售美国国债期货。使用 OCA 订单类型对两个订单进行分组为投资者提供了两次进入类似头寸的机会，同时只冒着承担单个头寸的风险。

```py
@staticmethod
def OneCancelsAll(ocaGroup:str, ocaOrders:ListOfOrder, ocaType:int):

    for o in ocaOrders:

    	o.ocaGroup = ocaGroup
    	o.ocaType = ocaType

    return ocaOrders 
```

```py
ocaOrders = [OrderSamples.LimitOrder("BUY", 1, 10), OrderSamples.LimitOrder("BUY", 1, 11),
                      OrderSamples.LimitOrder("BUY", 1, 12)]
OrderSamples.OneCancelsAll("TestOCA_" + str(self.nextValidOrderId), ocaOrders, 2)
for o in ocaOrders:
    self.placeOrder(self.nextOrderId(), ContractSamples.USStockAtSmart(), o) 
```

##### OCA 的类型

通过[IBApi.Order.OcaType](https://interactivebrokers.github.io/tws-api/classIBApi_1_1Order.html#a3485999c42d64f3c879ec4a424bab697)属性，可以配置执行后处理剩余订单的方式，如下表所示：

| 价值 | 描述 |
| --- | --- |
| 1 | 取消所有剩余的订单 with block。 |
| 2 | 剩余的订单规模将按比例减小 with block。 |
| 3 | 剩余的订单规模将按比例减小，with no block。 |

注意：如果您使用值"with block"，则会为订单提供超额成交保护。这意味着一次只能提交组中的一个订单，以消除超额成交的可能性。点击[此处](https://www.interactivebrokers.com/en/index.php?f=617)进一步讨论 OCA 的订单。

#### **Adjustable Stops**

您可以对 stop, stop limit, trailing stop and trailing stop limit orders 附加一次性调整。当您附加调整后的订单时，您可以设置触发价格，该价格将触发对原始（或父）订单的修改，而不是触发订单传输。

##### 给 stop 订单附加调整

```py
# Attached order is a conventional STP order in opposite direction
order = OrderSamples.Stop("SELL" if parent.action == "BUY" else "BUY",
                      parent.totalQuantity, attachedOrderStopPrice)
order.parentId = parent.orderId
#When trigger price is penetrated
order.triggerPrice = triggerPrice
#The parent order will be turned into a STP order
order.adjustedOrderType = "STP"
#With the given STP price
order.adjustedStopPrice = adjustStopPrice 
```

##### 给 stop limit 订单附加调整

```py
#Attached order is a conventional STP order
order = OrderSamples.Stop("SELL" if parent.action == "BUY" else "BUY",
                                   parent.totalQuantity, attachedOrderStopPrice)
order.parentId = parent.orderId
#When trigger price is penetrated
order.triggerPrice = triggerPrice
#The parent order will be turned into a STP LMT order
order.adjustedOrderType = "STP LMT"
#With the given stop price
order.adjustedStopPrice = adjustedStopPrice
#And the given limit price
order.adjustedStopLimitPrice = adjustedStopLimitPrice 
```

##### 给跟踪订单附加调整

```py
#Attached order is a conventional STP order
order = OrderSamples.Stop("SELL" if parent.action == "BUY" else "BUY",
                      parent.totalQuantity, attachedOrderStopPrice)
order.parentId = parent.orderId
#When trigger price is penetrated
order.triggerPrice = triggerPrice
#The parent order will be turned into a TRAIL order
order.adjustedOrderType = "TRAIL"
#With a stop price of...
order.adjustedStopPrice = adjustedStopPrice
#traling by and amount (0) or a percent (100)...
order.adjustableTrailingUnit = trailUnit
#of...
order.adjustedTrailingAmount = adjustedTrailAmount 
```

##### 订单调整

允许在满足一定条件的情况下激活订单

```py
mkt = OrderSamples.MarketOrder("BUY", 100)
# Order will become active if conditioning criteria is met
mkt.conditions.append(
            OrderSamples.PriceCondition(PriceCondition.TriggerMethodEnum.Default,
                                        208813720, "SMART", 600, False, False))
mkt.conditions.append(OrderSamples.ExecutionCondition("EUR.USD", "CASH", "IDEALPRO", True))
mkt.conditions.append(OrderSamples.MarginCondition(30, True, False))
mkt.conditions.append(OrderSamples.PercentageChangeCondition(15.0, 208813720, "SMART", True, True))
mkt.conditions.append(OrderSamples.TimeCondition("20160118 23:59:59", True, False))
mkt.conditions.append(OrderSamples.VolumeCondition(208813720, "SMART", False, 100, True))
self.placeOrder(self.nextOrderId(), ContractSamples.EuropeanStock(), mkt) 
```

或者取消他们

```py
lmt = OrderSamples.LimitOrder("BUY", 100, 20)
# The active order will be cancelled if conditioning criteria is met
lmt.conditionsCancelOrder = True
lmt.conditions.append(
           OrderSamples.PriceCondition(PriceCondition.TriggerMethodEnum.Last,
                                        208813720, "SMART", 600, False, False))
self.placeOrder(self.nextOrderId(), ContractSamples.EuropeanStock(), lmt) 
```

##### 价格条件

```py
#Conditions have to be created via the OrderCondition.create 
priceCondition = order_condition.Create(OrderCondition.Price)
#When this contract...
priceCondition.conId = conId
#traded on this exchange
priceCondition.exchange = exchange
#has a price above/below
priceCondition.isMore = isMore
priceCondition.triggerMethod = triggerMethod
#this quantity
priceCondition.price = price
#AND | OR next condition (will be ignored if no more conditions are added)
priceCondition.isConjunctionConnection = isConjunction 
```

#### 执行订单

```py
execCondition = order_condition.Create(OrderCondition.Execution)
#When an execution on symbol
execCondition.symbol = symbol
#at exchange
execCondition.exchange = exchange
#for this secType
execCondition.secType = secType
#AND | OR next condition (will be ignored if no more conditions are added)
execCondition.isConjunctionConnection = isConjunction 
```

##### 保证金条件

```py
marginCondition = order_condition.Create(OrderCondition.Margin)
#If margin is above/below
marginCondition.isMore = isMore
#given percent
marginCondition.percent = percent
#AND | OR next condition (will be ignored if no more conditions are added)
marginCondition.isConjunctionConnection = isConjunction 
```

##### 百分比条件

```py
pctChangeCondition = order_condition.Create(OrderCondition.PercentChange)
#If there is a price percent change measured against last close price above or below...
pctChangeCondition.isMore = isMore
#this amount...
pctChangeCondition.changePercent = pctChange
#on this contract
pctChangeCondition.conId = conId
#when traded on this exchange...
pctChangeCondition.exchange = exchange
#AND | OR next condition (will be ignored if no more conditions are added)
pctChangeCondition.isConjunctionConnection = isConjunction 
```

##### 时间条件

```py
timeCondition = order_condition.Create(OrderCondition.Time)
#Before or after...
timeCondition.isMore = isMore
#this time..
timeCondition.time = time
#AND | OR next condition (will be ignored if no more conditions are added) 
timeCondition.isConjunctionConnection = isConjunction 
```

##### 成交量条件

```py
volCond = order_condition.Create(OrderCondition.Volume)
#Whenever contract...
volCond.conId = conId
#When traded at
volCond.exchange = exchange
#reaches a volume higher/lower
volCond.isMore = isMore
#than this...
volCond.volume = volume
#AND | OR next condition (will be ignored if no more conditions are added)
volCond.isConjunctionConnection = isConjunction 
```